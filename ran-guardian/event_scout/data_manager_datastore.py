import google.cloud.datastore as datastore
import datetime
import inspect

DATABASE_NAME = "ran-guardian-people-events"

def get_client():
    """Initializes and returns a Firestore client."""
    return datastore.Client(database=DATABASE_NAME)

def create(data_type: str, item: dict) -> dict:
    """Adds a new item to the specified data type in Firestore."""
    client = get_client()
    key = client.key(data_type)  # Automatically generates an ID
    entity = datastore.Entity(key=key)

    # Add a created_at timestamp
    item["created_at"] = datetime.datetime.now(datetime.timezone.utc)

    entity.update(item)
    client.put(entity)
    item["id"] = entity.key.id # Assign the autogenerated ID to the item
    
    return item

def read_all(data_type: str) -> list[dict]:
    """Returns all items of the specified data type from Firestore."""
    client = get_client()
    query = client.query(kind=data_type)
    query.order = ["created_at"]
    
    print(f"Gemini just used {inspect.currentframe().f_code.co_name} function")

    results = list(query.fetch())
    
    # Add "id" to each item for consistency with your existing code
    for item in results:
        item["id"] = item.key.id

    return results

def read(data_type: str, id_key: str, id_value: int) -> dict | None:
    """Returns an item of the specified data type by its ID from Firestore."""
    client = get_client()
    
    # Datastore keys are integers but can be queried as strings
    key = client.key(data_type, id_value)
    entity = client.get(key)

    if entity:
        entity["id"] = entity.key.id
        return entity
    else:
        return None

def update(data_type: str, id_key: str, id_value: int, updates: dict) -> dict | None:
    """Updates an item of the specified data type by its ID in Firestore."""
    client = get_client()
    
    print(f"Gemini just used {inspect.currentframe().f_code.co_name} function")

    key = client.key(data_type, id_value)
    entity = client.get(key)

    if entity:
        # Add an updated_at timestamp
        updates["updated_at"] = datetime.datetime.now(datetime.timezone.utc)
        entity.update(updates)
        client.put(entity)
        entity["id"] = entity.key.id
        return entity
    else:
        return None

def delete(data_type: str, id_key: str, id_value: int) -> bool:
    """Deletes an item of the specified data type by its ID from Firestore."""
    client = get_client()
    
    print(f"Gemini just used {inspect.currentframe().f_code.co_name} function")

    key = client.key(data_type, id_value)
    entity = client.get(key)

    if entity:
        client.delete(key)
        return True
    else:
        return False

def read_date_range(data_type: str, start_date: datetime.datetime, end_date: datetime.datetime) -> list[dict]:
    """
    Filters items of a specified data type within a date range.

    Args:
        data_type: The data type (Firestore collection).
        start_date: The start date of the range (inclusive).
        end_date: The end date of the range (inclusive).

    Returns:
        A list of dictionaries, where each dictionary represents an item 
        within the specified date range.
    """
    client = get_client()
    query = client.query(kind=data_type)
    query.add_filter("created_at", ">=", start_date)
    query.add_filter("created_at", "<=", end_date)
    query.order = ["created_at"]  # Order by created_at ascending

    results = list(query.fetch())
    for item in results:
        item["id"] = item.key.id

    return results


if __name__ == "__main__":
    # --- Locations ---
    # Create
    new_location = {"location": "London", "comment": "Headquarters"}
    created_location = create("locations", new_location)
    print("Created Location:", created_location)

    # Read All
    all_locations = read_all("locations")
    print("All Locations:", all_locations)

    # Read by ID
    location = read("locations", "id", created_location["id"])  # Use the ID from the created item
    print("Location with ID:", location)

    # Update
    update("locations", "id", created_location["id"], {"comment": "Main Office"})
    location = read("locations", "id", created_location["id"])
    print("Updated Location:", location)

    # Read by date range
    start_date = datetime.datetime(2023, 1, 1, tzinfo=datetime.timezone.utc)
    end_date = datetime.datetime.now(datetime.timezone.utc)
    locations_in_range = read_date_range("locations", start_date, end_date)
    print("Locations in date range:", locations_in_range)


    # Delete
    # delete("locations", "id", created_location["id"])


    # --- EventTypes --- (Similar example) ---
    new_event_type = {"type": "Conference", "description": "Annual meeting"}
    created_event_type = create("event_types", new_event_type)
    print("Created EventType:", created_event_type)

    all_event_types = read_all("event_types")
    print("All EventTypes:", all_event_types)

    event_type = read("event_types", "id", created_event_type["id"])
    print("EventType with ID:", event_type)

    update("event_types", "id", created_event_type["id"], {"description": "Yearly conference"})
    event_type = read("event_types", "id", created_event_type["id"])
    print("EventType with ID:", event_type)

    # delete("event_types", "id", created_event_type["id"])